{% extends "pi/common/base.html" %}
{% load staticfiles %}

{% block custom_css %}
    <style type="text/css">
      html, body, #map-canvas { height: 100%; margin: 0; padding: 0;}
    </style>
{% endblock %}

{% block content %}
{% csrf_token %}
<div id="map-canvas" style="height:640px;width:100%;"></div>
{% endblock %}

{% block custom_js %}
    <script type="text/javascript"
    	src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBs9Lh9SBeGg8azzB5h50y8DDjxFO4SLwA">
    </script>

    {# JS hash library #}
    <script type="text/javascript" 
    	src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/md5.js">
    </script>
    
    {# Google map marker cluster #}
    {# http://google-maps-utility-library-v3.googlecode.com/svn/trunk/markerclustererplus/docs/examples.html #}
    <script type="text/javascript" 
    	src="{% static 'js/markerclusterer.js' %}">
    </script>

    <script type="text/javascript">
    	var j$ = jQuery.noConflict();
    	var map, mapCluster;
    	var mcOptions = {
    		gridSize: 100, 
    		maxZoom: 13,
    		minimumClusterSize: 3
    	};
    	var markers={}, info_wins={};

		function initialize() {
			var mapOptions = {
				center: { lat: {{ center.lat }}, lng: {{ center.lng }} },
				zoom: 5
			};
			map = new google.maps.Map(document.getElementById('map-canvas'), mapOptions);
			google.maps.event.addListener(map,'idle',updateMarkers);
		}
		google.maps.event.addDomListener(window, 'load', initialize);

        // register infowin to marker
        function registerInfoWin(hash,marker,content){
            var info_win = new google.maps.InfoWindow({
                content: content
            });

            // register a click event to popup info win
            google.maps.event.addListener(marker, 'mouseover', function() {
                info_win.open(map,marker);
            }); 
            google.maps.event.addListener(marker, 'mouseout', function() {
                info_win.close(map,marker);
            }); 

            // update hash table
            info_wins[hash]=info_win;
        }

        function getMarkerDetail (marker, obj_id, url){
            j$.post(
                url,
                {
                    'obj_id':obj_id
                },
                function(resp){
                    console.log(resp);
                },'json'
            );
        }

		// update map markers based on viewport
		function updateMarkers(){
			var bounds = map.getBounds();
			var ne = bounds.getNorthEast();
			var sw = bounds.getSouthWest();

			// ajax to server to get a list of markers that are within the viewport
			j$.post("{{ marker_url }}", // passed in from view
					{ 
                	'ne.k': ne.k,
                	'ne.D':ne.D,
                	'sw.k': sw.k,
                	'sw.D':sw.D 
            		}, 
            		function(resp) { // success callback
            			var show_keys = [];
            			var show_markers = [];
            			var hide_markers = [];

				  		// iterate through markers to add remove old ones from map and add new ones
                		for (var i=0; i<resp.length; i++){
                			// Must use toString. Otherwise a comparsion to markers' key will fail!
                			var hash = CryptoJS.MD5(resp[i].name).toString();
                			show_keys.push(hash);
                			if (!markers.hasOwnProperty(hash)) {
	                			var pos = new google.maps.LatLng(resp[i].lat,resp[i].lng);
	                			var marker = new google.maps.Marker({
	                				position: pos,
	                				map: map,
	                				title: resp[i].name,
                                    obj_id: resp[i].obj_id 
	                			});

                                // register a click event to read record details on request
                                google.maps.event.addListener(marker, 'click',function(){
                                    getMarkerDetail(this, this.obj_id, "{{ detail_url }}");
                                });
                                // register infowin
                                registerInfoWin(hash,marker,resp[i].info_win);

                                // update hashtable
	                			markers[hash]=marker;
	                		}
                		}

						for (var m in markers){
							if (show_keys.indexOf(m) != -1) { //show
								show_markers.push(markers[m]);
							}else { // hide
								hide_markers.push(markers[m]);
							}
						}

                		if (mapCluster == null || mapCluster == undefined) {
                			mapCluster = new MarkerClusterer(map, show_markers, mcOptions);
                		}else {
	                		mapCluster.removeMarkers(hide_markers);
	                		mapCluster.addMarkers(show_markers);
                		}   
            		},'json'
            	);		
		}
    </script>

{% endblock %}